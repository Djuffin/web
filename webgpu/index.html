<!DOCTYPE html>
<html>
    <head>
        <meta charset="UTF-8">
        <title>WebGPU Demo</title>
          <style>
            canvas {
              padding: 10px;
              background: gold;
            }
          </style>
    </head>
    <body>
        <canvas id="screen" width="800" height="800"></canvas>
        <script>
            async function main() {
              const cnv = document.getElementById("screen");
              const adapter = await navigator.gpu.requestAdapter();
              const device = await adapter.requestDevice();
              const ctx = cnv.getContext('webgpu');
              const presentationFormat = ctx.getPreferredFormat(adapter);
              const shaderCode = document.getElementById("shaders").text;

              ctx.configure({
                device,
                format: presentationFormat
              });
              const pipeline = device.createRenderPipeline({
                vertex: {
                  module: device.createShaderModule({
                    code: shaderCode,
                  }),
                  entryPoint: 'mainVertex',
                  buffers: [
                    {
                      arrayStride: 3 * 4,
                      stepMode: "vertex",
                      attributes: [
                        {
                          // position
                          shaderLocation: 0,
                          offset: 0,
                          format: 'float32x3',
                        },
                      ],
                    },
                  ],
                },
                fragment: {
                  module: device.createShaderModule({
                    code: shaderCode,
                  }),
                  entryPoint: 'mainFragment',
                  targets: [
                    {
                      format: presentationFormat,
                    },
                  ],
                },
                primitive: {
                  topology: 'triangle-list',
                  frontFace: "ccw"
                },
              });


              let vertices = new Float32Array([
                                               0.0,0.0,0.0,  -1.0,0.0,0.0,  -1.0,-1.0,0.0,
                                               0.0,0.0,0.0,   0.0,1.0,0.0,  1.0,1.0,0.0, ]);

              async function nextFrame() {
                const commandEncoder = device.createCommandEncoder();
                const textureView = ctx.getCurrentTexture().createView();

                const renderPassDescriptor = {
                  colorAttachments: [
                    {
                      view: textureView,
                      clearValue: { r: 0.3, g: 0.3, b: 0.3, a: 1.0 },
                      loadOp: 'clear',
                      storeOp: 'store',
                    },
                  ],
                };

                for  (let i = 0; i < vertices.length; i += 3) {
                  vertices[i] += 0.02;
                  if (vertices[i] > 2.0)
                    vertices[i] = -2.0;
                  vertices[i + 1] += 0.02;
                  if (vertices[i + 1] > 2.0)
                    vertices[i + 1] = -2.0;
                }

                const verticesBuffer = device.createBuffer({
                  size: vertices.byteLength,
                  usage: GPUBufferUsage.VERTEX,
                  mappedAtCreation: true,
                });
                new Float32Array(verticesBuffer.getMappedRange()).set(vertices);
                verticesBuffer.unmap();


                const passEncoder = commandEncoder.beginRenderPass(renderPassDescriptor);
                passEncoder.setPipeline(pipeline);
                passEncoder.setVertexBuffer(0, verticesBuffer);
                passEncoder.draw(6, 1, 0, 0);
                passEncoder.end();

                device.queue.submit([commandEncoder.finish()]);
                requestAnimationFrame(nextFrame);
                verticesBuffer.destroy();
              }
              nextFrame();
            }

            window.onload = main;
        </script>
        <script id="shaders" type="wgsl">
          @stage(vertex)
          fn mainVertex(@location(0) position : vec3<f32>,
                        @builtin(vertex_index) vertexIndex : u32,
                        @builtin(instance_index) instanceIndex : u32)
               -> @builtin(position) vec4<f32> {

            let scale = vec3<f32>(0.5, 0.5, 0.5);
            return vec4<f32>(position * scale, 1.0);
          }

          @stage(fragment)
          fn mainFragment(@builtin(front_facing) is_front: bool) -> @location(0) vec4<f32> {
            if (is_front) {
              return vec4<f32>(0.8, 0.0, 0.0, 1.0);
            } else {
              return vec4<f32>(0.0, 0.8, 0.0, 1.0);
            }

          }
        </script>

    </body>
</html>