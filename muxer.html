<html>
  <head>
    <meta charset="UTF-8">
    <title>Web Video Encoder test website</title>

</head>
<body>
  <img id='frame_image'  src="https://upload.wikimedia.org/wikipedia/commons/thumb/6/66/SMPTE_Color_Bars.svg/800px-SMPTE_Color_Bars.svg.png">
  <video id="player" width="800px" height="600px" autoplay controls></video>
  <script>
    'use strict';

    let mediaSource = new MediaSource();
    let sourceBuffer = null;
    let pendingData = [];

    function pushPendingData() {
      if (pendingData.length == 0 || sourceBuffer.updating)
        return;

      let size = pendingData.reduce((total, buf) => {return total + buf.length}, 0);
      let data = new Uint8Array(size);
      let end_index = 0;
      pendingData.forEach(buf => {
        data.set(buf, end_index);
        end_index += buf.length;
      });
      console.assert(end_index == size);
      sourceBuffer.appendBuffer(data);
      pendingData = [];
    }

    function closeStream() {
      if (!sourceBuffer.updating)
        mediaSource.endOfStream();
    }

    function muxedDataArrived(data) {
      pendingData.push(new Uint8Array(data));
      pushPendingData();
    }

    function sourceOpen() {
      if (mediaSource.readyState != "open")
        return;

      sourceBuffer = mediaSource.addSourceBuffer('video/webm; codecs="vp8"');
      sourceBuffer.removeEventListener('sourceopen', sourceOpen);
      sourceBuffer.addEventListener('updateend', pushPendingData);
      let video = document.querySelector('#player');
      URL.revokeObjectURL(video.src);
      generate_video().then(x => {
        if (sourceBuffer.updating) {
          sourceBuffer.addEventListener('updateend', closeStream);
        } else {
          closeStream();
        }
      });
    }

    async function generateBitmap(width, height, text) {
      if (!generateBitmap.ctx) {
        generateBitmap.img = document.getElementById('frame_image');
        generateBitmap.cnv = document.createElement("canvas");
        generateBitmap.cnv.height = height;
        generateBitmap.cnv.width = width;
        generateBitmap.ctx = generateBitmap.cnv.getContext('2d');
      }
      let cnv = generateBitmap.cnv;
      let ctx = generateBitmap.ctx;
      let img = generateBitmap.img;
      ctx.drawImage(img, 0, 0, width, height);

      ctx.fillStyle = 'white';
      ctx.font = '50px Monospace';
      ctx.fillText(text, width / 10, height / 10);
      return createImageBitmap(cnv);
    }

    async function createFrame(width, height, ts, dur) {
      let imageBitmap = await generateBitmap(width, height,
                              "Timestamp: " + (ts / 1000));
      return new VideoFrame({ timestamp: ts, duration: dur }, imageBitmap);
    }

    function delay(t) {
      return new Promise((resolve) => setTimeout(resolve.bind(null), t));
    }

    async function generate_video() {
      let w = 800;
      let h = 600;
      let frame_rate = 25;
      let next_ts = 0
      let full_duration = 120;
      let frames_to_encode = frame_rate * full_duration;
      let frames_processed = 0;

      let muxer = new Module.Muxer(muxedDataArrived, w, h, false);

      let process_video_chunk = function(chunk) {
        let data = new Uint8Array(chunk.data);
        let duration = 1000000 / frame_rate;
        let result = muxer.AddFrame(data, (chunk.type == "key"),
                              chunk.timestamp, duration);
        frames_processed++;
      };

      const init_params = {
        codec : "vp8",
        tuneOptions : {
          width : w,
          height : h,
          bitrate: 20e6,
          framerate: frame_rate
        },
        output : process_video_chunk,
        error: (e) => { console.log(e.message); }
      };
      let encoder = new VideoEncoder();
      await encoder.configure(init_params);

      for (let i = 0; i < frames_to_encode; i++) {
        let ts = 1000000 * i / frame_rate;
        let frame = await createFrame(w, h, ts);
        let keyframe = (i % (frame_rate * 2) == 0);
        await encoder.encode(frame, { keyFrame : keyframe});
      }
      await encoder.flush();
      await encoder.close();
      muxer.Finalize();
      muxer.delete();
    }

    function main() {
      if (typeof VideoEncoder == "undefined") {
        alert("WebCodecs not supported. Try adding --enable-blink-features=WebCodecs");
        return;
      }
      let video = document.querySelector('#player');
      video.src = window.URL.createObjectURL(mediaSource);
      mediaSource.addEventListener('sourceopen', sourceOpen, false);
    }

    var Module = {
      onRuntimeInitialized: main,
      print: function(t) {
          console.log("stdout:" + t);
      },
      printErr: function(t) {
          console.log("stderr:" + t);
      },
    };
  </script>
   <script src="muxer.js"></script>
</body>
</html>