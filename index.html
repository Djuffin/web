<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8">
    <title>Face blur</title>
    <style>
        button {
            border: solid;
            margin: 15px 32px;
            width: 150px;
            text-align: center;
            display: block;
            font-size: 16px;
        }

        #screen {
            border: solid;
        }
    </style>
    <script>

        function waitFor(delay_ms) {
          return new Promise((resolve, _) => {
            setTimeout(resolve, delay_ms);
          });
        }

        function createDecodedStream(dataUri) {
            const decoder_worker = new Worker("./decoder_worker.js");
            const ready_frames = [];
            let next_frame_ready_callback = null;
            function onFrame(frame) {
                if (!frame) {
                    decoder_worker.terminate();
                }
                if (next_frame_ready_callback) {
                    next_frame_ready_callback(frame);
                    next_frame_ready_callback = null;
                }
                else
                    ready_frames.push(frame);
            }
            decoder_worker.addEventListener("message", message => onFrame(message.data));
            decoder_worker.postMessage({dataUri});

            async function getNextFrame() {
                if (ready_frames.length > 0)
                    return ready_frames.shift();

                let next_frame_promise = new Promise((resolve, reject) => {
                    next_frame_ready_callback = resolve;
                });
                return next_frame_promise;
            }
            return getNextFrame;
        }

        class FrameProcessor {
            constructor(width, height, backend) {
                this.frames = [];
                this.worker = new Worker("./frame_processing.js");
                this.worker.onmessage = (e) => {
                    this.onFrame(e.data);
                };
                this.worker.postMessage({
                    command : 'init',
                    options : {width, height, backend}
                });
            }

            async processFrame(frame) {
                this.worker.postMessage({
                    command : 'frame',
                    frame: frame
                }, [frame]);

                let next_frame_promise = new Promise((resolve, reject) => {
                    this.next_frame_ready_callback = resolve;
                });
                return next_frame_promise;
            }

            onFrame(frame) {
                if (!frame) {
                    this.close();
                }
                if (this.next_frame_ready_callback) {
                    this.next_frame_ready_callback(frame);
                    this.next_frame_ready_callback = null;
                }
            }

            close() {
                this.worker.terminate();
            }
        }

        async function getCameraInputReader(constraints) {
            const stream = await window.navigator.mediaDevices.getUserMedia(constraints);
            const track = stream.getTracks()[0];
            const media_processor = new MediaStreamTrackProcessor(track);
            const reader = media_processor.readable.getReader();
            async function getNextFrame() {
                const { done, value } = await reader.read();
                if (done) {
                    return null;
                }
                const frame = value;
                return frame;
            }
            return getNextFrame;
        }

        async function main() {
            const width = 1280;
            const height = 720;
            const frames_in_parallel = 5;
            const processors = [];
            const desired_fps = 60;
            //const constraints = { audio: false, video:  { width: width, height: height, frameRate: desired_fps } };
            //let frameReader = await getCameraInputReader(constraints);
            const original_cnv = document.querySelector('#original_cnv');
            let canvas_width = width / 2;
            let canvas_height = height / 2;
            original_cnv.width = canvas_width;
            original_cnv.height = canvas_height;
            const original_ctx = original_cnv.getContext('2d', {alpha : false});

            const modified_cnv = document.querySelector('#modified_cnv');
            modified_cnv.width = canvas_width;
            modified_cnv.height = canvas_height;
            const modified_ctx = modified_cnv.getContext('2d', {alpha : false});

            console.log("begin init");
            for (let i = 0; i < frames_in_parallel; i++) {
                let processor = new FrameProcessor(width, height, '');
                processors.push(processor);
            }


            let frameReader = createDecodedStream('./friends.mp4');
            console.log("end init");

            let start_time = performance.now();
            let decoded_frame_counter = 0;
            let processed_frame_counter = 0;

            let end_of_stream = false;
            while (!end_of_stream) {
                let decoded_frames = [];

                let i = 0;
                for (i = 0; i < frames_in_parallel; i++) {
                    let frame = await frameReader();
                    if (!frame) {
                        end_of_stream = true;
                        break;
                    }

                    decoded_frame_counter++;
                    decoded_frames.push(frame);
                }

                if (decoded_frames.length > 0)
                    original_ctx.drawImage(decoded_frames[0], 0, 0, canvas_width, canvas_height);

                i = 0;
                let promises = [];
                for (let frame of decoded_frames) {
                    let processor = processors[i++];
                    promises.push(processor.processFrame(frame));
                }

                let processed_frames = await Promise.all(promises);
                processed_frames.sort((f1, f2) => { return f1.timestamp - f2.timestamp });

                if (processed_frames.length > 0)
                    modified_ctx.drawImage(processed_frames[0], 0, 0, canvas_width, canvas_height);
                for (let processed_frame of processed_frames) {
                    processed_frame_counter++;
                    processed_frame.close();
                }
            }
            let end_time = performance.now();
            for (let p of processors)
                p.close();

            let label = document.createElement('pre');
            document.body.appendChild(label);
            label.innerText = `FPS: ${decoded_frame_counter / (end_time - start_time) * 1000}`;
        }
    </script>

</head>

<body>
    <div>
        <button onclick="main()">Start</button>
        <canvas id='original_cnv'></canvas>
        <canvas id='modified_cnv'></canvas>
    </div>
</body>

</html>